#include<bits/stdc++.h>
using namespace std;

/*
        #ifndef ONLINE_JUDGE

                freopen("input.txt", "r", stdin);

                freopen("output.txt", "w", stdout);

        #endif 

*/

unsigned long long int p[10]={};// to distribute the NOs 0 - 9 and the no of stars represent its probability
          //i have done this to form a bell curve for easy representation
          //the results of poisson process  stored on an array is hard to comprehend for me 
          //since we are to basically do a statistical test later for the central node the bell curve might 
          //eazy for jayesh and myself to comprehend  later
vector<pair<int,int>>p1;// this is a vector to store the final indices of the matrix for graph formation

//function for transmission loss
double transmissionloss( pair<int,int> x1, pair<int,int> x2,int  lam, int alpha)

{
   double dist= sqrt(pow(x2.first - x1.first, 2) +  
                pow(x2.second - x1.second, 2) * 1.0);


   double loss = 10*lam*log10 (dist) + alpha*dist;
   return loss;

}


// fucntion to construct a  a graph
//second entry as double is the transmission loss for us all
int makegraph( vector<pair<int,int>>&p1)
{
            #ifndef ONLINE_JUDGE

                freopen("input.txt", "r", stdin);

                freopen("output.txt", "w", stdout);

        #endif 
    int size= p1.size();
    vector<pair<int,double>>graph[size];//this is our graph 
    for( int i=0 ; i< size; i++)
    {
        for( int j=i+1 ; j< size; j++)
        {
            double z =transmissionloss( p1[i], p1[j],  1,1);
            graph[i].push_back(make_pair(j, z));
            graph[j].push_back(make_pair(i, z));
        }
    }
    
   /* for( int i=0 ; i< size; i++)
    {
        for( int j=i+1 ; j< size; j++)
        {
            cout<<graph[i][j].first<<" f"<<graph[i][j].second<<" s";
        }
        cout<<endl;
    }
    */
    return 0;
}



int poisson( double x)
{
     
#ifndef ONLINE_JUDGE

                freopen("input.txt", "r", stdin);

                freopen("output.txt", "w", stdout);

        #endif 
    //code generated by sourabh kumar 
    // the below two lines are just a measure  by  me to  to represent the data of poisson experiment
    //in terms of probability
  int exp_no = 10000; // NO of experiments
   int curve_dist = 100;   // maximum NO of stars to distribute

  default_random_engine generator;

  poisson_distribution<int> distribution(x);// I have used an inbuilt function with the input of the mean

  
  for (int i=0; i<exp_no; ++i) {
    int NO = distribution(generator);
    if (NO<10) ++p[NO];
  }
  /*
  // this array just represents the result of poisson process
  for( int i=0  ; i < 10 ; i++)
  {
    cout<< p[i]<<" ";
  }
  cout<< endl;
  cout<<endl;
    
  // converting the results in terms of probability to make bell curve
  // higher the number of stars the higher the probability of the number

  std::cout << "poisson_distribution (mean="<<x<<")"<< endl;
  for (int i=0; i<10; ++i)
    cout << i << ": " <<string(p[i]*curve_dist/exp_no,'*') << endl;
    */

  return 0;
}

int Poissionpointprocess( float lambda)
{   int xmin =0 ;
    int xmax= 50;//xmax and ymax must be same for this code to work
                    //it makes it easier to handle the overflow conditions
    int ymin = 0; 
    int ymax =50;
    int xdim= xmax - xmin;//this gives me the side of the rectangle
    int ydim = ymax - ymin;
    int area =xdim*ydim; // area of the rectangle
    int matrix[xdim][ydim]; // the rectangle that we are using
    
    memset(matrix, 0 , sizeof(matrix));
    
    float meanpoisson= area*lambda; // finding the mean of our scattering matrix
    

    poisson(meanpoisson);//fill the global p matrix with generated poission numbers
    
    
    vector<int>xcord; //vector to simulate the xcordinate of the throw
    vector<int>ycord; // vector to throw y cordinate of the throw
    srand( (unsigned)time( NULL ) );

    int x = rand()%10 +1;
    
    unsigned long long int index= p[x];// basically generate a randomly generated poission number
   

    

    
    
    float arr[index];  //to generate a  random number between 0 and 1 ( this is basically to simulate poission process)
     srand( (unsigned)time( NULL ) );
  
    for(int i = 0; i<index; i++) 
    {
        arr[i]=  ((float) rand() / ((RAND_MAX)+1) );
       
    }

    for( int i=0 ; i< index ; i++)
    {
        xcord.push_back((xdim*arr[i])+ xmin); // get the x value of cordinates
        
        

    }

    
    for(int i = 0; i<index; i++) 
    {
        arr[i]=  ((double) rand() / (RAND_MAX)) + 1;
        
    }
    for( int i=0 ; i< index ; i++)
    {
        ycord.push_back((ydim*arr[i])+ ymin); // get y value of corfinates
        
    }
    
    
    
    
    for( int i=0 ; i< index ; i++)
    {   
        
        matrix[xcord[i]%50][ycord[i]%50]=1; //generate the matrix

        
    }
   for( int i=0 ; i< ymax; i++)
    {
        for( int j=0 ; j< xmax ; j++)
        {
            if( matrix[i][j]==1)
            {
            p1.push_back(make_pair(i,j));
            }
        }
    }
    makegraph( p1);
   /* for( int i=0 ; i< p1.size(); i++)
    {
        cout<<p1[i].first<<" "<<p1[i].second<<" ";
    }
    cout<<endl;
    cout<<endl;
    */   
    /*for( int i=0 ; i< ymax ; i++)
    {
        for( int j =0 ; j< xmax ; j++)
        {
            cout<<matrix[i][j]<<" ";
        }
        cout<<endl;
    }
    */
    
    
    
   // cout<<xcord.size()<<" "<<ycord.size()<<endl;
 

    return 0;
}



int main()
{
    
    
    
    Poissionpointprocess( .0005);
    

}